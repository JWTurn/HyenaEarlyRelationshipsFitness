### Hyena/Spatsoc - Association ====
# Alec Robitaille
# March 01 2019

### Notes ----
# undirected, Twice weight index

### Packages ----
libs <- c('data.table', 'spatsoc', 'asnipe', 'igraph')
lapply(libs, require, character.only = TRUE)

### Import data ----
raw <- dir('data/raw-data', full.names = TRUE)

asso <- fread(raw[grepl('asso', raw)])
egos <- fread(raw[grepl('egos', raw)])

### Prep ----
# Date columns
asso[, sessiondate := as.IDate(sessiondate)]
asso[, yr := year(sessiondate)]
asso[, datetime := as.POSIXct(sessiondate)]

# Cast session to an integer group column
asso[, group := .GRP, session]

# TODO: why nulls in sessiondate?
asso <- asso[!is.na(year(sessiondate))]

### Association ----
## Random+Observed
# Daily type randomizations
# (within each day, randomize individuals)
n <- 3
randDaily <- randomizations(
	asso,
	type = 'daily',
	id = 'hyena',
	group = 'group',
	datetime = 'datetime',
	iterations = n,
	splitBy = 'yr'
)

# Create a data.table of unique combinations of iteration and year, including observed and random rows
iterYearLs <- unique(randDaily[, .(iteration, yr)])

## Generate group by individual matrix
# for each combination of iteration and year
# 'group' generated by spatsoc::group_pts
# 'randomID' used instead of observed ID (type = 'step')
gbiLs <- mapply(FUN = function(i, y) {
	get_gbi(randDaily[iteration == i & yr == y],
					'group', 'randomID')
},
i = iterYearLs$iter,
y = iterYearLs$yr
)

## Generate a list of random networks
#TODO: what kind of association index?
netLs <- lapply(gbiLs, FUN = get_network,
								data_format = "GBI", association_index = "HWI")

## Generate graph and calculate network metrics
mets <- lapply(seq_along(netLs), function(n) {
	g <- graph.adjacency(netLs[[n]], 'undirected',
											 diag = FALSE, weighted = TRUE)

	data.table(
		centrality = evcent(g)$vector,
		strength = graph.strength(g),
		ID = names(degree(g)),
		iteration = iterYearLs$iter[[n]],
		yr = iterYearLs$yr[[n]]
	)
})

## Observed and random for all individuals across all iterations and years
out <- rbindlist(mets)

## Split observed and random
out[, observed := ifelse(iteration == 0, TRUE, FALSE)]

## Mean values for each individual and year, by observed/random
meanMets <- out[, lapply(.SD, mean), by = .(ID, yr, observed),
								.SDcols = c('centrality', 'strength')]




### For your own interest... ----
## Observed
yearLs <- asso[, unique(year(sessiondate))]

netLs <- lapply(yearLs, function(yr) {
	# Build group by individual matrix
	gbiMtrx <- get_gbi(asso[year(sessiondate) == yr],
										 group = 'group', id = 'hyena')

	## Generate observed network
	#TODO: what association index?
	net <- get_network(gbiMtrx,
										 data_format = "GBI",
										 association_index = "SRI")
})

mets <- lapply(seq_along(netLs), function(n) {
	g <- graph_from_adjacency_matrix(netLs[[n]], 'undirected',
																	 diag = FALSE, weighted = TRUE)

	#TODO: which network metrics?
	data.table(
		centrality = eigen_centrality(g)$vector,
		strength = strength(g),
		ID = names(degree(g)),
		yr = yearLs[[n]]
	)
})

association <- rbindlist(mets)
association
