### Hyena/Spatsoc - Association ====
# Alec Robitaille
# March 01 2019

### Notes ----
# undirected, Twice weight index

### Packages ----
libs <- c('data.table', 'spatsoc', 'asnipe', 'igraph')
lapply(libs, require, character.only = TRUE)

### Import data ----
derived <- dir('data/derived-data', full.names = TRUE)

asso <- readRDS(derived[grepl('association-life', derived)])

### Prep ----
# Date columns
asso[, sessiondate := as.IDate(sessiondate)]
asso[, yr := year(sessiondate)]
asso[, datetime := as.POSIXct(sessiondate)]

# Cast session to an integer group column
asso[, group := .GRP, session]

idCol <- 'idlife'
groupCol <- 'group'

### Association ----
## Random+Observed
# Daily type randomizations
# (within each day, randomize individuals)
n <- 3
randDaily <- randomizations(
	asso,
	type = 'daily',
	id = idCol,
	group = groupCol,
	datetime = 'datetime',
	iterations = n,
	splitBy = 'yr'
)

# Create a data.table of unique combinations of iteration and year, including observed and random rows
iterYearLs <- unique(randDaily[, .(iteration, yr)])

## Generate group by individual matrix
# for each combination of iteration and year
# 'group' generated by spatsoc::group_pts
# 'randomID' used instead of observed ID (type = 'step')
gbiLs <- mapply(FUN = function(i, y) {
	get_gbi(randDaily[iteration == i & yr == y],
					groupCol, 'randomID')
},
i = iterYearLs$iter,
y = iterYearLs$yr
)

## Generate a list of random networks
#TODO: what kind of association index?
netLs <- lapply(gbiLs, FUN = get_network,
								data_format = "GBI", association_index = "HWI")

## Generate graph and calculate network metrics
mets <- lapply(seq_along(netLs), function(n) {
	g <- graph.adjacency(netLs[[n]], 'undirected',
											 diag = FALSE, weighted = TRUE)

	# TODO: Are these the network metrics you want? Add them here...
	# degree, outdegree, indegree, strength, outstrength, instrength, betweenness
	data.table(
		degree = degree(g),
		outdegree = degree(g, mode = 'out'),
		indegree = degree(g, mode = 'in'),
		strength = strength(g),
		outstrength = strength(g, mode = 'out'),
		instrength = strength(g, mode = 'in'),
		betweenness = betweenness(g, directed = FALSE),
		ID = names(degree(g)),
		iteration = iterYearLs$iter[[n]],
		yr = iterYearLs$yr[[n]]
	)
})

## Observed and random for all individuals across all iterations and years
out <- rbindlist(mets)
setnames(out, 'ID', idCol)

## Split observed and random
out[, observed := ifelse(iteration == 0, TRUE, FALSE)]

## Mean values for each individual and year, by observed/random
meanMets <- out[, lapply(.SD, mean), by = c(idCol, 'yr', 'observed'),
								.SDcols = colnames(out)[1:7]]

saveRDS(meanMets, 'data/derived-data/mean-mets-association.Rds')
